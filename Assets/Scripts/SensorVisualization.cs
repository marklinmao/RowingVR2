using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI;  public class SensorVisualization : MonoBehaviour {      private List<Vector3> accelBuffer = new List<Vector3>();     private const int ACCEL_BUFFER_SIZE = 200;      public GameObject textAccelX;     public GameObject textAccelY;     public GameObject textAccelZ;      public GameObject lineAccelX;     private LineRenderer lineRendererAccelX;      public GameObject lineAccelY;     private LineRenderer lineRendererAccelY;      public GameObject lineAccelZ;     private LineRenderer lineRendererAccelZ;      public GameObject lineAccelWaveX;     private LineRenderer lineRendererAccelXWave;       //The scale is for making sure that the line doesn't exceed the visualization panel     private float timeScale = 100f;     private float dataScale = 180f;       private List<float> accelXSingleWaveBuffer = new List<float>();     private List<List<float>> accelXWaveBuffer = new List<List<float>>();     private List<float> accelXPeakBuffer = new List<float>();     private const int ACCEL_WAVE_BUFFER_SIZE = 10;     private const float THRESHOLD_ACCEL_X = -10f;     private bool waveXSwitchOn = false;       private int exceedCounter = 0;     private float lastExceedEndTime = 0f;




    void Start () {         lineRendererAccelX = (LineRenderer)lineAccelX.GetComponent("LineRenderer");         lineRendererAccelX.positionCount = ACCEL_BUFFER_SIZE;          lineRendererAccelY = (LineRenderer)lineAccelY.GetComponent("LineRenderer");         lineRendererAccelY.positionCount = ACCEL_BUFFER_SIZE;          lineRendererAccelZ = (LineRenderer)lineAccelZ.GetComponent("LineRenderer");         lineRendererAccelZ.positionCount = ACCEL_BUFFER_SIZE;          lineRendererAccelXWave = (LineRenderer)lineAccelWaveX.GetComponent("LineRenderer");         lineRendererAccelXWave.positionCount = ACCEL_BUFFER_SIZE;     }       void Update () {          float timestamp = Time.realtimeSinceStartup;          Vector3 accel = GvrControllerInput.Accel;         textAccelX.GetComponent<Text>().text = accel.x.ToString("F2");         textAccelY.GetComponent<Text>().text = accel.y.ToString("F2");         textAccelZ.GetComponent<Text>().text = accel.z.ToString("F2");          //push to buffer         PushToBuffer(accel);          //visualize the whole accel buffer         VisualizeAccelBuffer();             Debug.Log("-------------->waveBuffer:"+ accelXWaveBuffer.Count + ", singleWaveBuffer:" + accelXSingleWaveBuffer.Count + ", switchOn="+waveXSwitchOn + ", exceedCounter=" + exceedCounter);                    if (IsAccelXThresholdExceeded(accel.x))         {                            if (!waveXSwitchOn) //that means it start to exceed the threshold             {                                  exceedCounter++;                 Debug.Log(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>超出!>>>>>>>>>>");                                    //switch on the flag                 waveXSwitchOn = true;                  //clear the single wave buffer to get prepared                 accelXSingleWaveBuffer.Clear();                               }              if (waveXSwitchOn)             {                 //push to single wave buffer                 accelXSingleWaveBuffer.Add(accel.x);             }         }         else         {             if (waveXSwitchOn) //that means is get back to normal             {                 Debug.Log("<<<<<<<<<< 恢复!!! <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<");                  //switch off the flag                 waveXSwitchOn = false;                   if(Time.realtimeSinceStartup - lastExceedEndTime > 0.5f) //this is for avoid noise, sometimes the accelerometer bounce back and it also exceed the threshold
                {
                    //copy single wave buffer to wave buffer
                    PushToAccelXWaveBuffer(accelXSingleWaveBuffer);

                    lastExceedEndTime = Time.realtimeSinceStartup;

                    //calculate the peak
                    //CalculateAccelXPeak(accelXSingleWaveBuffer);
                }

            }         }          //visualize wave buffer         VisualizeAccelWaveBuffer();      }        private bool IsAccelXThresholdExceeded(float accelX)     {         return accelX <= THRESHOLD_ACCEL_X;     }      private void PushToBuffer(Vector3 accel)     {         if (accelBuffer.Count >= ACCEL_BUFFER_SIZE)             accelBuffer.RemoveAt(0);         accelBuffer.Add(accel);     }      private void PushToAccelXWaveBuffer(List<float> accelXWave)     {         if (accelXWaveBuffer.Count >= ACCEL_WAVE_BUFFER_SIZE)             accelXWaveBuffer.RemoveAt(0);          List<float> newList = new List<float>(accelXWave.ToArray());         accelXWaveBuffer.Add(newList);     }      private void PushToAccelXPeakBuffer(float peak)     {         if (accelXPeakBuffer.Count >= ACCEL_WAVE_BUFFER_SIZE)             accelXPeakBuffer.RemoveAt(0);         accelXPeakBuffer.Add(peak);     }      private void CalculateAccelXPeak(List<float> accelXWave)     {         float accelXMax = GetMax(accelXWave);          PushToAccelXPeakBuffer(accelXMax);          //TODO broadcast event here...      }      private float GetMax(List<float> wave)     {         float maxValue = 0f;         foreach (float waveValue in wave)         {             if (waveValue > maxValue)                 maxValue = waveValue;         }          return maxValue;     }      private void VisualizeAccelBuffer()     {         int index = 0;         foreach(Vector3 accel in accelBuffer)         {             lineRendererAccelX.SetPosition(index, new Vector3(index / timeScale, accel.x / dataScale, 0));             //lineRendererAccelY.SetPosition(index, new Vector3(index / timeScale, accel.y / dataScale, 0));             //lineRendererAccelZ.SetPosition(index, new Vector3(index / timeScale, accel.z / dataScale, 0));              index++;         }     }      private void VisualizeAccelWaveBuffer()     {         int index = 0;         string overview = "";          foreach (List<float> wave in accelXWaveBuffer)         {             overview += wave.Count + "-";              foreach (float value in wave)             {                 lineRendererAccelXWave.SetPosition(index, new Vector3(index / timeScale, value / (dataScale/2), 0));                  index++;             }              //print some space             for(int i = 0; i < 15; i ++)             {                 lineRendererAccelXWave.SetPosition(index, new Vector3(index / timeScale, 0, 0));                 index++;             }         }          Debug.Log("-----------Overview: " + overview);      } } 